@page "/paint/{sessionId}"
@using System.Diagnostics
@using System.Security.Claims
@using System.Threading.Channels
@using System.Threading.Tasks
@using Akka.Actor
@using Akka.Hosting
@using DrawTogether.Actors.Local
@using DrawTogether.Components.Draw
@using DrawTogether.Entities
@using DrawTogether.Entities.Drawings
@using DrawTogether.Entities.Drawings.Messages
@using DrawTogether.Entities.Users
@using Microsoft.AspNetCore.Authorization
@using DrawingColor = DrawTogether.Entities.Drawings.Color
@using MudBlazor
@using Microsoft.Extensions.Logging
@inject NavigationManager NavigationManager;
@implements IAsyncDisposable;
@inject AuthenticationStateProvider GetAuthenticationStateAsync
@inject IRequiredActor<LocalDrawingSessionActor> LocalDrawingSessionActor;
@inject ILogger<Paint> Logger
@attribute [Authorize]

<div class="d-flex flex-column h-100" style="height: 100vh; overflow: hidden;">
    <!-- Compact Header with dropdown -->
    <MudAppBar Dense="true" Color="MudBlazor.Color.Primary" Class="px-2" Style="height: 48px;" Fixed="false">
        <MudText Typo="Typo.h6">Paint with [@ConnectedUsers.Count] People</MudText>
        <MudSpacer />
        <MudMenu Icon="@Icons.Material.Filled.Group" Color="MudBlazor.Color.Inherit" Dense="true">
            <MudText Typo="Typo.subtitle2" Class="px-4 py-2">Connected Users</MudText>
            <MudDivider />
        @foreach (var user in ConnectedUsers)
        {
                <MudMenuItem>@user.IdentityName</MudMenuItem>
            }
        </MudMenu>
    </MudAppBar>
    
    <!-- Main Content Area -->
    <div class="d-flex flex-grow-1 position-relative" style="height: calc(100vh - 48px); overflow: hidden;">
        <!-- Fixed Vertical Toolstrip with flexible width -->
        <MudPaper Elevation="2" Class="pa-2" Style="width: auto; min-width: 280px; height: 100%; overflow-y: auto;">
            <MudText Typo="Typo.subtitle1" Class="mb-2">Drawing Tools</MudText>
            
            <div class="mb-3 d-flex justify-center">
                <MudColorPicker 
                    @bind-Text="_colorString" 
                    Label="Color" 
                    Style="@($"color: {_colorString}; width: 100%;")" 
                    Placeholder="Select Color" 
                    PickerVariant="PickerVariant.Static"
                    DisableModeSwitch="false"
                    DisablePreview="false"
                    DisableInputs="true"
                    DisableSliders="false"
                    Class="pb-2"
                    ColorPickerView="ColorPickerView.Spectrum"
                    Elevation="0" />
            </div>
            
            <MudText Typo="Typo.body2" Class="mb-1">Cursor Size: @_cursorSize.Value</MudText>
            <MudSlider 
                Value="@_cursorSize.Value" 
                Min="1" 
                Max="50" 
                ValueChanged="@((int value) => UpdateCursorSize(value))"
                Class="mb-4"/>
            
            <MudButton 
                Variant="Variant.Filled" 
                Color="MudBlazor.Color.Error" 
                FullWidth="true"
                OnClick="ResetScreen">
                Clear Screen
            </MudButton>
</MudPaper>
        
        <!-- Drawing Area with proper boundaries -->
        <MudPaper Elevation="3" Class="flex-grow-1 position-relative" Style="height: 100%; overflow: hidden;">
            <div id="paint" 
                 style="background-color: cornsilk; width: 100%; height: 100%;"
                 @onmousemove="CursorMove" 
                 @onmousedown="CursorDown" 
                 @onmouseup="CursorUp"
                 @ontouchmove="HandleTouchMove"
                 @ontouchstart="HandleTouchStart"
                 @ontouchend="HandleTouchEnd"
                 @ref="canvasElement">
                
                <svg width="100%" height="100%" preserveAspectRatio="xMidYMid meet" viewBox="0 0 1200 800">
                    <g transform="@_transformMatrix">
                        <Circle 
                            radius="@_cursorSize.Value" 
                            cursorId="@_currentUserId!.IdentityName" 
                            cX="@cX" 
                            cY="@cY" 
                            fillColor="@_color.HexCodeOrColorName" 
                            borderColor="@_color.HexCodeOrColorName"/>
                        
                @foreach (var connectedStroke in Strokes.Values)
                {
                            <Curve 
                                Points="@connectedStroke.Points" 
                                Stroke="@connectedStroke.StrokeColor.HexCodeOrColorName" 
                                StrokeWidth="@connectedStroke.StrokeWidth.Value"/>
                }
                    </g>
            </svg>
            </div>
        </MudPaper>
    </div>
</div>

@code {

    [Parameter] public required string SessionId { get; set; }

    public Dictionary<StrokeId, ConnectedStroke> Strokes { get; set; } = new();

    public HashSet<UserId> ConnectedUsers { get; set; } = [];

    public DateTime LastUpdate { get; set; } = DateTime.UtcNow;

    DrawingSessionId? DrawingSessionId { get; set; }

    private ChannelReader<IDrawingSessionEvent>? _eventStream = null;

    private IActorRef? _localActorHandle;
    private readonly CancellationTokenSource _shutdownCts = new();
    private CancellationTokenSource? _readDoneCts;
    
    private ElementReference canvasElement;
    private string _transformMatrix = ""; // For cursor position correction

    private ClaimsPrincipal? _user;
    private UserId? _currentUserId;

    protected override async Task OnInitializedAsync()
    {
        var authstate = await GetAuthenticationStateAsync.GetAuthenticationStateAsync();
        _user = authstate.User;
        _currentUserId = new UserId(_user.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new InvalidOperationException("User not authenticated"));
        DrawingSessionId = new DrawingSessionId(SessionId);


        using var startupCts = new CancellationTokenSource(5000);
        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(startupCts.Token, _shutdownCts.Token);
        var localActor = await LocalDrawingSessionActor.GetAsync(linkedCts.Token);

        await DoStartupTasks(linkedCts.Token);

        async Task DoStartupTasks(CancellationToken ct)
        {
            var localHandleTask = localActor.Ask<IActorRef>(new LocalDrawingSessionActor.GetLocalActorHandle(DrawingSessionId), cancellationToken: ct);
            var currentStateTask = localActor.Ask<DrawingSessionState>(
                new DrawingSessionQueries.GetDrawingSessionState(DrawingSessionId), cancellationToken: ct);
            var eventStreamTask = localActor.Ask<LocalDrawingSessionActor.DrawingChannelResponse>(
                new LocalDrawingSessionActor.GetDrawingChannel(DrawingSessionId), cancellationToken: ct);

            await Task.WhenAll(localHandleTask, currentStateTask, eventStreamTask);

            _localActorHandle = await localHandleTask;
            var localState = await currentStateTask;
            var readTools = await eventStreamTask;
            _eventStream = readTools.DrawingChannel;
            _readDoneCts = readTools.DoneReading;

            // unpack the local state
            foreach (var stroke in localState.Strokes)
            {
                Strokes[stroke.Key] = stroke.Value;
            }

            foreach (var user in localState.ConnectedUsers)
            {
                ConnectedUsers.Add(user);
            }

            // let the local actor know that the current user has joined the session
            _localActorHandle.Tell(new LocalPaintProtocol.JoinPaintSession(DrawingSessionId, _currentUserId));

            // start the event loop
            _ = RunDataPump();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Initialize canvas measurements for cursor correction
            await CalculateCanvasTransform();
        }
    }

    private async Task CalculateCanvasTransform()
    {
        try
        {
            // For now, use a simple transform that works with our viewBox dimensions
            _transformMatrix = "";
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error calculating canvas transform");
        }
    }

    async Task RunDataPump()
    {
        Debug.Assert(_eventStream != null, nameof(_eventStream) + " != null");
        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(_shutdownCts.Token, _readDoneCts!.Token);
        while (!linkedCts.IsCancellationRequested && await _eventStream.WaitToReadAsync(linkedCts.Token))
        while (_eventStream.TryRead(out var evt))
        {
            HandleEvent(evt);
            await InvokeAsync(StateHasChanged);
        }

        // signal to local actor that we are done reading
        _readDoneCts?.CancelAsync();

        // navigate us to home if the stream dies out 
        NavigationManager.NavigateTo("/");
    }

    private void HandleEvent(IDrawingSessionEvent item)
    {
        switch (item)
        {
            case DrawingSessionEvents.UserAdded userJoined:
                ConnectedUsers.Add(userJoined.UserId);
                break;
            case DrawingSessionEvents.UserRemoved userLeft:
                ConnectedUsers.Remove(userLeft.UserId);
                break;
            case DrawingSessionEvents.StrokeAdded strokeAdded:
                Strokes[strokeAdded.Stroke.Id] = strokeAdded.Stroke;
                break;
            case DrawingSessionEvents.StrokeRemoved strokeRemoved:
                Strokes.Remove(strokeRemoved.StrokeId);
                break;
            case DrawingSessionEvents.StrokesCleared:
                Strokes.Clear();
                break;
            default:
                throw new ArgumentOutOfRangeException(nameof(item));
        }

        LastUpdate = DateTime.UtcNow;
    }


    double cX = 110.0d;
    double cY = 110.0d;
    private string _colorString = "black";
    private DrawingColor _color => new(_colorString);
    private GreaterThanZeroInteger _cursorSize = new(8);

    private void CursorDown(MouseEventArgs e)
    {
        if (e.Buttons == 1)
        {
            OnNext(new Point(e.OffsetX, e.OffsetY));
        }
    }

    private void OnNext(Point point)
    {
        _localActorHandle?.Tell(new LocalPaintProtocol
            .AddPointToConnectedStroke(point, DrawingSessionId!, _currentUserId!, _cursorSize, _color));
    }

    private void CursorMove(MouseEventArgs e)
    {
        cX = e.OffsetX;
        cY = e.OffsetY;
        if (e.Buttons == 1)
        {
            OnNext(new Point(e.OffsetX, e.OffsetY));
        }
    }

    private void CursorUp(MouseEventArgs e)
    {
        if (e.Buttons == 1)
        {
            OnNext(new Point(e.OffsetX, e.OffsetY));
        }
    }

    // Touch event handlers for mobile support
    private void HandleTouchStart(TouchEventArgs e)
    {
        if (e.TargetTouches.Length > 0)
        {
            var touch = e.TargetTouches[0];
            cX = touch.ClientX;
            cY = touch.ClientY;
            OnNext(new Point(touch.ClientX, touch.ClientY));
        }
    }

    private void HandleTouchMove(TouchEventArgs e)
    {
        if (e.TargetTouches.Length > 0)
        {
            var touch = e.TargetTouches[0];
            cX = touch.ClientX;
            cY = touch.ClientY;
            OnNext(new Point(touch.ClientX, touch.ClientY));
        }
    }

    private void HandleTouchEnd(TouchEventArgs e)
    {
        // No additional actions needed for touch end in this case
    }

    private void UpdateCursorSize(int cursorSize)
    {
        _cursorSize = new GreaterThanZeroInteger(cursorSize);
    }

    private void ResetScreen()
    {
        Debug.Assert(DrawingSessionId != null, nameof(DrawingSessionId) + " != null");
        Debug.Assert(_currentUserId != null, nameof(_currentUserId) + " != null");
        _localActorHandle.Tell(new LocalPaintProtocol.ClearDrawingSession(DrawingSessionId, _currentUserId));
    }


    public async ValueTask DisposeAsync()
    {
        _readDoneCts?.CancelAsync();
        _readDoneCts?.Dispose();
        await _shutdownCts.CancelAsync();
        if (DrawingSessionId != null && _currentUserId is not null) 
            _localActorHandle.Tell(
                new LocalPaintProtocol.LeavePaintSession(DrawingSessionId, _currentUserId));
        _shutdownCts.Dispose();
    }

}